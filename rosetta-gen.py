#!/usr/bin/env python3
"""
rosetta-gen: Generate Rosetta wrappers from IDL

Usage:
    python rosetta-gen.py api.rosetta.yaml --output generated/
"""

import yaml
import argparse
from pathlib import Path
from typing import List, Dict, Any

class RosettaGenerator:
    def __init__(self, idl_file: str):
        with open(idl_file, 'r') as f:
            self.idl = yaml.safe_load(f)
        self.types = self.idl['types']
        self.dependencies = self.idl.get('dependencies', [])
    
    def generate_all(self, output_dir: Path):
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Sort types by dependencies
        sorted_types = self.topological_sort()
        
        print(f"Generating wrappers for {len(sorted_types)} types...")
        
        # Generate wrappers
        for type_info in sorted_types:
            self.generate_wrapper_header(type_info, output_dir)
            self.generate_wrapper_source(type_info, output_dir)
        
        # Generate binding file
        self.generate_binding_file(sorted_types, output_dir)
        
        # Generate CMakeLists.txt
        self.generate_cmake_file(sorted_types, output_dir)
        
        # Generate Node.js specific files
        self.generate_binding_gyp(sorted_types, output_dir)
        self.generate_package_json(output_dir)
        
        print("\nGeneration complete!")
    
    def topological_sort(self) -> List[Dict]:
        """Sort types by dependencies"""
        # Build dependency graph
        graph = {t['name']: [] for t in self.types}
        for dep in self.dependencies:
            if dep['to'] in graph:  # Only add if target exists
                graph[dep['from']].append(dep['to'])
        
        # Kahn's algorithm for topological sort
        in_degree = {t['name']: 0 for t in self.types}
        for deps in graph.values():
            for dep in deps:
                if dep in in_degree:
                    in_degree[dep] += 1
        
        queue = [name for name, degree in in_degree.items() if degree == 0]
        result = []
        
        while queue:
            node = queue.pop(0)
            type_info = next(t for t in self.types if t['name'] == node)
            result.append(type_info)
            
            for neighbor in graph.get(node, []):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        if len(result) != len(self.types):
            print("Warning: Circular dependency detected. Some types may not be ordered correctly.")
        
        return result
    
    def generate_wrapper_header(self, type_info: Dict, output_dir: Path):
        """Generate wrapper header file"""
        wrapper_name = f"I{type_info['name']}"
        original_type = self.get_full_type_name(type_info)
        include_path = type_info.get('include', f"{type_info['name']}.h")
        
        lines = [
            "/*",
            " * Auto-generated by rosetta-gen",
            " * DO NOT EDIT MANUALLY",
            " */",
            "#pragma once",
            "#include <rosetta/rosetta.h>",
            f"#include {self.format_include_path(include_path)}",
            "",
            # "namespace Rosetta {",
            "",
            f"class {wrapper_name} : public rosetta::Introspectable {{",
            f"    INTROSPECTABLE({wrapper_name})",
            "private:",
            f"    {original_type} original;",
            "",
            "public:",
            "    // Constructors",
        ]
        
        # Constructors
        for ctor in type_info.get('constructors', []):
            params = ', '.join(ctor.get('params', []))
            lines.append(f"    {wrapper_name}({params});")
        
        lines.extend([
            "",
            "    // Access to original",
            f"    {original_type}& getOriginal() {{ return original; }}",
            f"    const {original_type}& getOriginal() const {{ return original; }}",
            "",
        ])
        
        # Properties (getters/setters)
        if type_info.get('properties'):
            lines.append("    // Properties (getters/setters)")
            for prop in type_info['properties']:
                name_cap = prop['name'].capitalize()
                prop_type = prop['type']
                lines.append(f"    {prop_type} get{name_cap}() const;")
                if prop.get('access') == 'read-write':
                    lines.append(f"    void set{name_cap}({prop_type} value);")
            lines.append("")
        
        # Methods
        if type_info.get('methods'):
            lines.append("    // Methods")
            for method in type_info['methods']:
                params = ', '.join(method.get('params', []))
                const = " const" if method.get('const', False) else ""
                lines.append(f"    {method['return']} {method['name']}({params}){const};")
            lines.append("")
        
        lines.extend([
            "};",
            "",
            # "} // namespace Rosetta",
            ""
        ])
        
        output_file = output_dir / f"{wrapper_name}.h"
        with open(output_file, 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"  Generated: {output_file}")
    
    def generate_wrapper_source(self, type_info: Dict, output_dir: Path):
        """Generate wrapper source file"""
        wrapper_name = f"I{type_info['name']}"
        
        lines = [
            "/*",
            " * Auto-generated by rosetta-gen",
            " * DO NOT EDIT MANUALLY",
            " */",
            f'#include "{wrapper_name}.h"',
            "",
            # "namespace Rosetta {",
            "",
            "// Constructors",
        ]
        
        # Constructors implementation
        for ctor in type_info.get('constructors', []):
            params = ctor.get('params', [])
            param_str = ', '.join(params)
            param_names = ', '.join(p.split()[-1] for p in params)
            
            lines.extend([
                f"{wrapper_name}::{wrapper_name}({param_str})",
                f"    : original({param_names}) {{}}",
                ""
            ])
        
        # Properties implementation
        if type_info.get('properties'):
            lines.append("// Properties")
            for prop in type_info['properties']:
                name_cap = prop['name'].capitalize()
                prop_type = prop['type']
                prop_name = prop['name']
                
                # Getter
                lines.extend([
                    f"{prop_type} {wrapper_name}::get{name_cap}() const {{",
                    f"    return original.{prop_name};",
                    "}",
                    ""
                ])
                
                # Setter
                if prop.get('access') == 'read-write':
                    lines.extend([
                        f"void {wrapper_name}::set{name_cap}({prop_type} value) {{",
                        f"    original.{prop_name} = value;",
                        "}",
                        ""
                    ])
        
        # Methods implementation
        if type_info.get('methods'):
            lines.append("// Methods")
            for method in type_info['methods']:
                params = method.get('params', [])
                param_str = ', '.join(params)
                param_names = ', '.join(p.split()[-1] for p in params)
                const = " const" if method.get('const', False) else ""
                ret = "" if method['return'] == 'void' else "return "
                
                lines.extend([
                    f"{method['return']} {wrapper_name}::{method['name']}({param_str}){const} {{",
                    f"    {ret}original.{method['name']}({param_names});",
                    "}",
                    ""
                ])
        
        # Registration
        lines.extend([
            "// Registration",
            f"void {wrapper_name}::registerIntrospection(rosetta::TypeRegistrar<{wrapper_name}> reg) {{",
            "    reg",
        ])
        
        # Register constructors
        for ctor in type_info.get('constructors', []):
            params = ctor.get('params', [])
            # Extract only the types, removing variable names
            param_types = self.extract_param_types(params)
            param_types_str = ', '.join(param_types) if param_types else ""
            lines.append(f"       .constructor<{param_types_str}>()")
        
        # Register properties
        for prop in type_info.get('properties', []):
            name_cap = prop['name'].capitalize()
            lines.append(f'       .method("get{name_cap}", &{wrapper_name}::get{name_cap})')
            if prop.get('access') == 'read-write':
                lines.append(f'       .method("set{name_cap}", &{wrapper_name}::set{name_cap})')
        
        # Register methods
        for method in type_info.get('methods', []):
            lines.append(f'       .method("{method["name"]}", &{wrapper_name}::{method["name"]})')
        
        lines.extend([
            "       ;",
            "}",
            "",
            # "} // namespace Rosetta",
            ""
        ])
        
        output_file = output_dir / f"{wrapper_name}.cpp"
        with open(output_file, 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"  Generated: {output_file}")
    
    def generate_binding_file(self, sorted_types: List[Dict], output_dir: Path):
        """Generate main binding file"""
        lines = [
            "/*",
            " * Auto-generated by rosetta-gen",
            " * DO NOT EDIT MANUALLY",
            " */",
            "#include <rosetta/generators/js.h>",
        ]
        
        # Include all wrappers
        for type_info in sorted_types:
            wrapper_name = f"I{type_info['name']}"
            lines.append(f'#include "{wrapper_name}.h"')
        
        lines.extend([
            "",
            "BEGIN_JS(generator) {",
        ])
        
        # Register original types with their fully qualified names (only if namespaced)
        has_namespaced_types = any(type_info.get('namespace', '').strip() for type_info in sorted_types)
        
        if has_namespaced_types:
            lines.append("    // Register original types with their fully qualified names")
            for type_info in sorted_types:
                namespace = type_info.get('namespace', '').strip()
                if namespace:  # Only register if namespace is present
                    full_type_name = self.get_full_type_name(type_info)
                    lines.append(f'    rosetta::TypeNameRegistry::instance().register_type<{full_type_name}>("{full_type_name}");')
            lines.append("")
        
        lines.append("    // Register wrapper classes in dependency order")
        
        # Register all wrapper classes
        for type_info in sorted_types:
            wrapper_name = f"I{type_info['name']}"
            export_name = type_info.get('export_as', type_info['name'])
            # lines.append(f'    registerAllForClass<Rosetta::{wrapper_name}>(generator, "{export_name}");')
            lines.append(f'    registerAllForClass<{wrapper_name}>(generator, "{export_name}");')
        
        lines.extend([
            "}",
            "END_JS();",
            ""
        ])
        
        output_file = output_dir / "bindings.cpp"
        with open(output_file, 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"  Generated: {output_file}")
    
    def generate_binding_gyp(self, sorted_types: List[Dict], output_dir: Path):
        """Generate binding.gyp for node-gyp build system"""
        
        # Get project name from IDL or use default
        project_name = self.idl.get('config', {}).get('project_name', 'myapi')
        
        # Get custom include directories from config
        custom_includes = self.idl.get('config', {}).get('include_dirs', [])
        rosetta_include = self.idl.get('config', {}).get('rosetta_include_dir', '../rosetta/include')
        
        # Collect all wrapper source files
        sources = []
        for type_info in sorted_types:
            wrapper_name = f"I{type_info['name']}"
            sources.append(f"{wrapper_name}.cpp")
        sources.append("bindings.cpp")
        
        # Build the binding.gyp structure
        gyp = {
            "targets": [
                {
                    "target_name": project_name,
                    "sources": sources,
                    "include_dirs": [
                        "<!@(node -p \"require('node-addon-api').include\")",
                        rosetta_include
                    ] + custom_includes,
                    "dependencies": [
                        "<!(node -p \"require('node-addon-api').gyp\")"
                    ],
                    "cflags!": ["-fno-exceptions", "-fno-rtti"],
                    "cflags_cc!": ["-fno-exceptions", "-fno-rtti"],
                    "cflags_cc": [
                        "-std=c++20",
                        "-fexceptions",
                        "-frtti"
                    ],
                    "xcode_settings": {
                        "GCC_ENABLE_CPP_EXCEPTIONS": "YES",
                        "GCC_ENABLE_CPP_RTTI": "YES",
                        "CLANG_CXX_LANGUAGE_STANDARD": "c++20",
                        "CLANG_CXX_LIBRARY": "libc++",
                        "MACOSX_DEPLOYMENT_TARGET": "10.14",
                        "OTHER_CPLUSPLUSFLAGS": [
                            "-std=c++20",
                            "-fexceptions",
                            "-frtti"
                        ]
                    },
                    "msvs_settings": {
                        "VCCLCompilerTool": {
                            "ExceptionHandling": 1,
                            "RuntimeTypeInfo": "true",
                            "AdditionalOptions": [
                                "/std:c++20"
                            ]
                        }
                    },
                    "conditions": [
                        ["OS==\"win\"", {
                            "defines": [
                                "_HAS_EXCEPTIONS=1"
                            ]
                        }]
                    ]
                }
            ]
        }
        
        # Write binding.gyp as formatted JSON
        output_file = output_dir / "binding.gyp"
        with open(output_file, 'w') as f:
            import json
            json.dump(gyp, f, indent=2)
        
        print(f"  Generated: {output_file}")
    
    def generate_package_json(self, output_dir: Path):
        """Generate package.json for Node.js project"""
        
        # Get config from IDL
        config = self.idl.get('config', {})
        project_name = config.get('project_name', 'myapi')
        version = config.get('version', '1.0.0')
        description = config.get('description', f'Node.js bindings for {project_name}')
        author = config.get('author', '')
        license_type = config.get('license', 'LGPL-3.0-or-later')
        
        package_json = {
            "name": project_name,
            "version": version,
            "description": description,
            "main": "index.js",
            "scripts": {
                "install": "node-gyp rebuild",
                "build": "node-gyp build",
                "clean": "node-gyp clean",
                "test": "node test.js"
            },
            "gypfile": True,
            "dependencies": {
                "node-addon-api": "^7.0.0"
            },
            "devDependencies": {
                "node-gyp": "^10.0.0"
            },
            "keywords": [
                "cpp", "c++",
                "javascript",
                "nodejs",
                "napi",
                "bindings",
                "native",
                "addon",
                project_name
            ],
            "license": license_type
        }
        
        # Add author if provided
        if author:
            package_json["author"] = author
        
        # Write package.json as formatted JSON
        output_file = output_dir / "package.json"
        with open(output_file, 'w') as f:
            import json
            json.dump(package_json, f, indent=2)
            f.write('\n')  # Add trailing newline
        
        print(f"  Generated: {output_file}")
    
    def generate_cmake_file(self, sorted_types: List[Dict], output_dir: Path):
        """Generate CMakeLists.txt for the bindings"""
        
        # Get project name from IDL or use default
        project_name = self.idl.get('config', {}).get('project_name', 'myapi')
        
        lines = [
            "# Auto-generated by rosetta-gen",
            "# DO NOT EDIT MANUALLY",
            "",
            "cmake_minimum_required(VERSION 3.15)",
            f"project({project_name}_bindings)",
            "",
            "set(CMAKE_CXX_STANDARD 20)",
            "set(CMAKE_CXX_STANDARD_REQUIRED ON)",
            "set(CMAKE_CXX_EXTENSIONS ON)",
            "",
            "# Build options",
            "option(BUILD_NODE_ADDON \"Build Node.js addon\" OFF)",
            "option(BUILD_PYTHON_ADDON \"Build Python addon\" OFF)",
            "",
            "# Find required packages",
            "include_directories(${ROSETTA_INCLUDE_DIR})",
            "",
            "# Collect all generated wrapper sources",
            "set(WRAPPER_SOURCES",
        ]
        
        # Add all wrapper source files
        for type_info in sorted_types:
            wrapper_name = f"I{type_info['name']}"
            lines.append(f"    {wrapper_name}.cpp")
        
        lines.extend([
            "    bindings.cpp",
            ")",
            "",
            "# Create bindings library",
            f"add_library({project_name}_bindings SHARED",
            "    ${WRAPPER_SOURCES}",
            ")",
            "",
            "# Link against original library and rosetta",
            f"target_link_libraries({project_name}_bindings",
            f"    {project_name}  # Your original API library",
            "    rosetta",
            ")",
            "",
            "# Include directories",
            f"target_include_directories({project_name}_bindings PUBLIC",
            "    ${CMAKE_CURRENT_SOURCE_DIR}",
            ")",
            "",
            "# ============================================================================",
            "# Node.js Addon Configuration",
            "# ============================================================================",
            "if(BUILD_NODE_ADDON)",
            "    message(STATUS \"Building Node.js addon\")",
            "    ",
            "    # Find Node.js",
            "    find_program(NODE_EXECUTABLE NAMES node nodejs REQUIRED)",
            "    ",
            "    # Check if node-addon-api is installed",
            "    execute_process(",
            "        COMMAND ${NODE_EXECUTABLE} -p \"try { require.resolve('node-addon-api'); 'installed' } catch(e) { 'not-installed' }\"",
            "        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}",
            "        OUTPUT_VARIABLE NODE_ADDON_API_STATUS",
            "        OUTPUT_STRIP_TRAILING_WHITESPACE",
            "    )",
            "    ",
            "    if(NODE_ADDON_API_STATUS STREQUAL \"not-installed\")",
            "        message(STATUS \"node-addon-api not found, installing...\")",
            "        execute_process(",
            "            COMMAND ${NODE_EXECUTABLE} -e \"require('child_process').execSync('npm install node-addon-api', {stdio: 'inherit'})\"",
            "            WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}",
            "            RESULT_VARIABLE NPM_INSTALL_RESULT",
            "        )",
            "        if(NOT NPM_INSTALL_RESULT EQUAL 0)",
            "            message(FATAL_ERROR \"Failed to install node-addon-api. Please run: npm install node-addon-api\")",
            "        endif()",
            "    else()",
            "        message(STATUS \"node-addon-api is already installed\")",
            "    endif()",
            "    ",
            "    # Get node-addon-api include directory",
            "    execute_process(",
            "        COMMAND ${NODE_EXECUTABLE} -p \"require('node-addon-api').include\"",
            "        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}",
            "        OUTPUT_VARIABLE NODE_ADDON_API_DIR",
            "        OUTPUT_STRIP_TRAILING_WHITESPACE",
            "    )",
            "    ",
            "    # Get Node.js include directory",
            "    execute_process(",
            "        COMMAND ${NODE_EXECUTABLE} -p \"process.execPath\"",
            "        OUTPUT_VARIABLE NODE_EXEC_PATH",
            "        OUTPUT_STRIP_TRAILING_WHITESPACE",
            "    )",
            "    ",
            "    get_filename_component(NODE_ROOT_DIR \"${NODE_EXEC_PATH}\" DIRECTORY)",
            "    get_filename_component(NODE_ROOT_DIR \"${NODE_ROOT_DIR}\" DIRECTORY)",
            "    set(NODE_INCLUDE_DIR \"${NODE_ROOT_DIR}/include/node\")",
            "    ",
            "    # Verify Node.js headers exist",
            "    if(NOT EXISTS \"${NODE_INCLUDE_DIR}/node.h\")",
            "        message(FATAL_ERROR \"Node.js headers not found at ${NODE_INCLUDE_DIR}. \"",
            "                            \"Please install Node.js development headers.\")",
            "    endif()",
            "    ",
            f"    target_include_directories({project_name}_bindings PRIVATE",
            "        ${NODE_ADDON_API_DIR}",
            "        ${NODE_INCLUDE_DIR}",
            "        ${CMAKE_JS_INC}",
            "    )",
            "    ",
            "    # Define NAPI_VERSION",
            "    target_compile_definitions({project_name}_bindings PRIVATE NAPI_VERSION=8)",
            "    ",
            "    # Set Node.js addon properties",
            f"    set_target_properties({project_name}_bindings PROPERTIES",
            "        PREFIX \"\"",
            "        SUFFIX \".node\"",
            f"        OUTPUT_NAME \"{project_name}\"",
            "    )",
            "    ",
            "    message(STATUS \"Node.js include dir: ${NODE_INCLUDE_DIR}\")",
            "    message(STATUS \"node-addon-api dir: ${NODE_ADDON_API_DIR}\")",
            "endif()",
            "",
            "# ============================================================================",
            "# Python Addon Configuration",
            "# ============================================================================",
            "if(BUILD_PYTHON_ADDON)",
            "    message(STATUS \"Building Python addon\")",
            "    ",
            "    # Find Python",
            "    find_package(Python COMPONENTS Interpreter Development REQUIRED)",
            "    ",
            "    message(STATUS \"Python version: ${Python_VERSION}\")",
            "    message(STATUS \"Python include dir: ${Python_INCLUDE_DIRS}\")",
            "    message(STATUS \"Python library: ${Python_LIBRARIES}\")",
            "    ",
            "    # Check if pybind11 is installed",
            "    execute_process(",
            "        COMMAND ${Python_EXECUTABLE} -c \"import pybind11; print(pybind11.get_cmake_dir())\"",
            "        OUTPUT_VARIABLE PYBIND11_CMAKE_DIR",
            "        OUTPUT_STRIP_TRAILING_WHITESPACE",
            "        RESULT_VARIABLE PYBIND11_CHECK_RESULT",
            "    )",
            "    ",
            "    if(NOT PYBIND11_CHECK_RESULT EQUAL 0)",
            "        message(STATUS \"pybind11 not found, installing...\")",
            "        execute_process(",
            "            COMMAND ${Python_EXECUTABLE} -m pip install pybind11",
            "            RESULT_VARIABLE PIP_INSTALL_RESULT",
            "        )",
            "        if(NOT PIP_INSTALL_RESULT EQUAL 0)",
            "            message(FATAL_ERROR \"Failed to install pybind11. Please run: pip install pybind11\")",
            "        endif()",
            "        ",
            "        # Get pybind11 cmake dir again after installation",
            "        execute_process(",
            "            COMMAND ${Python_EXECUTABLE} -c \"import pybind11; print(pybind11.get_cmake_dir())\"",
            "            OUTPUT_VARIABLE PYBIND11_CMAKE_DIR",
            "            OUTPUT_STRIP_TRAILING_WHITESPACE",
            "        )",
            "    else()",
            "        message(STATUS \"pybind11 is already installed\")",
            "    endif()",
            "    ",
            "    # Add pybind11 cmake directory to module path",
            "    list(APPEND CMAKE_PREFIX_PATH \"${PYBIND11_CMAKE_DIR}\")",
            "    ",
            "    # Find pybind11",
            "    find_package(pybind11 REQUIRED)",
            "    ",
            "    message(STATUS \"pybind11 include dir: ${pybind11_INCLUDE_DIR}\")",
            "    ",
            "    # Add Python bindings target",
            f"    pybind11_add_module({project_name}_python",
            "        ${WRAPPER_SOURCES}",
            "    )",
            "    ",
            f"    target_link_libraries({project_name}_python PRIVATE",
            f"        {project_name}",
            "        rosetta",
            "    )",
            "    ",
            f"    target_include_directories({project_name}_python PRIVATE",
            "        ${CMAKE_CURRENT_SOURCE_DIR}",
            "        ${pybind11_INCLUDE_DIR}",
            "    )",
            "    ",
            "    # Set Python module properties",
            f"    set_target_properties({project_name}_python PROPERTIES",
            f"        OUTPUT_NAME \"{project_name}\"",
            "        PREFIX \"${PYTHON_MODULE_PREFIX}\"",
            "        SUFFIX \"${PYTHON_MODULE_EXTENSION}\"",
            "    )",
            "endif()",
            "",
            "# ============================================================================",
            "# Installation",
            "# ============================================================================",
            "if(BUILD_NODE_ADDON)",
            f"    install(TARGETS {project_name}_bindings",
            "        LIBRARY DESTINATION lib",
            "        RUNTIME DESTINATION bin",
            "    )",
            "endif()",
            "",
            "if(BUILD_PYTHON_ADDON)",
            f"    install(TARGETS {project_name}_python",
            "        LIBRARY DESTINATION ${Python_SITEARCH}",
            "    )",
            "endif()",
            "",
            "if(NOT BUILD_NODE_ADDON AND NOT BUILD_PYTHON_ADDON)",
            "    # Default installation for standalone library",
            f"    install(TARGETS {project_name}_bindings",
            "        LIBRARY DESTINATION lib",
            "        RUNTIME DESTINATION bin",
            "    )",
            "endif()",
            ""
        ])
        
        output_file = output_dir / "CMakeLists.txt"
        with open(output_file, 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"  Generated: {output_file}")
    
    def get_full_type_name(self, type_info: Dict) -> str:
        """Get full type name including namespace if specified"""
        name = type_info['name']
        namespace = type_info.get('namespace', '').strip()
        
        # Only add namespace if it's explicitly provided and not empty
        if namespace:
            return f"{namespace}::{name}"
        return name
    
    def extract_param_types(self, params: List[str]) -> List[str]:
        """Extract just the types from parameter declarations
        
        Examples:
            'double x' -> 'double'
            'const Point& p' -> 'const Point&'
            'std::vector<int> vec' -> 'std::vector<int>'
        """
        types = []
        for param in params:
            param = param.strip()
            if not param:
                continue
            
            # Split by whitespace and find the last token (variable name)
            # Everything before that is the type
            parts = param.split()
            if len(parts) == 1:
                # Just a type, no variable name (shouldn't happen but handle it)
                types.append(param)
            else:
                # Remove the last part (variable name)
                # Handle references and pointers: "const Point& p" -> "const Point&"
                type_part = ' '.join(parts[:-1])
                types.append(type_part)
        
        return types
    
    def format_include_path(self, include_path: str) -> str:
        """Format include path for #include directive
        
        Relative paths (starting with ../ or ./) are wrapped in quotes.
        Absolute paths (starting with < or containing /) are wrapped in angle brackets.
        Simple filenames are wrapped in angle brackets.
        """
        # Already has angle brackets or quotes
        if include_path.startswith('<') or include_path.startswith('"'):
            return include_path
        
        # Relative path (starts with ../ or ./)
        if include_path.startswith('../') or include_path.startswith('./'):
            return f'"{include_path}"'
        
        # Absolute or system include path (contains / or is a standard library)
        # Use angle brackets
        return f'<{include_path}>'


def main():
    parser = argparse.ArgumentParser(
        description='Generate Rosetta wrappers from IDL',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example IDL file (YAML):

  version: 1.0
  types:
    - name: Point
      namespace: MyAPI                # Optional: specify namespace
      include: "../api.h"             # Relative path (uses quotes)
      export_as: Point
      constructors:
        - params: []
        - params: [double x, double y, double z]
      properties:
        - {name: x, type: double, access: read-write}
        - {name: y, type: double, access: read-write}
      methods:
        - {name: magnitude, return: double, const: true, params: []}
    
    - name: Vector
      namespace: MyAPI::Geometry      # Nested namespace
      include: <myapi/vector.h>       # Absolute path (uses angle brackets)
      export_as: Vector
      constructors:
        - params: []
    
    - name: Matrix
      include: ./matrix.h             # No namespace (top-level type)
      export_as: Matrix
      constructors:
        - params: []
  
  dependencies:
    - {from: Mesh, to: Point}
        """)
    
    parser.add_argument('idl_file', help='Path to IDL file (YAML)')
    parser.add_argument('--output', '-o', default='generated', 
                       help='Output directory (default: generated)')
    
    args = parser.parse_args()
    
    try:
        generator = RosettaGenerator(args.idl_file)
        generator.generate_all(Path(args.output))
        
        print(f"\nGenerated files in: {args.output}/")
        print("\nNext steps:")
        print("1. Review generated files")
        print("2. Add to your build system (CMakeLists.txt)")
        print("3. Compile and test")
    except FileNotFoundError:
        print(f"Error: IDL file not found: {args.idl_file}")
        return 1
    except yaml.YAMLError as e:
        print(f"Error parsing YAML: {e}")
        return 1
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0


if __name__ == '__main__':
    exit(main())